<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />




<title>Authoring Crosstalk widgets</title>

<script src="site_libs/jquery-1.11.3/jquery.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/cosmo.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<link href="site_libs/highlightjs-1.1/textmate.css" rel="stylesheet" />
<script src="site_libs/highlightjs-1.1/highlight.js"></script>
<link rel="stylesheet" type="text/css" href="site_libs/bootstrap-3.3.5/css/cosmo.min.css"/>

<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
  pre:not([class]) {
    background-color: white;
  }
</style>
<script type="text/javascript">
if (window.hljs && document.readyState && document.readyState === "complete") {
   window.setTimeout(function() {
      hljs.initHighlighting();
   }, 0);
}
</script>



<style type="text/css">
h1 {
  font-size: 34px;
}
h1.title {
  font-size: 38px;
}
h2 {
  font-size: 30px;
}
h3 {
  font-size: 24px;
}
h4 {
  font-size: 18px;
}
h5 {
  font-size: 16px;
}
h6 {
  font-size: 12px;
}
.table th:not([align]) {
  text-align: left;
}
</style>


</head>

<body>

<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
code {
  color: inherit;
  background-color: rgba(0, 0, 0, 0.04);
}
img {
  max-width:100%;
  height: auto;
}
.tabbed-pane {
  padding-top: 12px;
}
button.code-folding-btn:focus {
  outline: none;
}
</style>


<style type="text/css">
/* padding for bootstrap navbar */
body {
  padding-top: 51px;
  padding-bottom: 40px;
}
/* offset scroll position for anchor links (for fixed navbar)  */
.section h1 {
  padding-top: 56px;
  margin-top: -56px;
}

.section h2 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h3 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h4 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h5 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h6 {
  padding-top: 56px;
  margin-top: -56px;
}
</style>

<script>
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark it active
  menuAnchor.parent().addClass('active');

  // if it's got a parent navbar menu mark it active as well
  menuAnchor.closest('li.dropdown').addClass('active');
});
</script>


<div class="container-fluid main-container">

<!-- tabsets -->
<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});
</script>

<!-- code folding -->






<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html">Crosstalk</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="index.html">Home</a>
</li>
<li>
  <a href="using.html">Using</a>
</li>
<li>
  <a href="authoring.html">Authoring</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Reference (JS)
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="filter.html">FilterHandle</a>
    </li>
    <li>
      <a href="selection.html">SelectionHandle</a>
    </li>
  </ul>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div class="fluid-row" id="header">



<h1 class="title toc-ignore">Authoring Crosstalk widgets</h1>

</div>


<p>If you’re the author of an htmlwidget, this tutorial will help you determine whether it is a good candidate for Crosstalk integration, and tell you how to begin.</p>
<div id="fundamental-concepts" class="section level2">
<h2>Fundamental concepts</h2>
<p>A few main concepts form the foundation for interaction in Crosstalk.</p>
<ul>
<li><strong>Shared data</strong> - A single data frame (or data frame-like object) that is shared between all linked visualizations/filter controls.</li>
<li><strong>Key</strong> - A string that uniquely identifies a row within a shared data object (similar to a primary key in a SQL table, or the concept of keys in d3). In non-Shiny settings, this is usually just the row number. When using Shiny, it can sometimes be helpful to identify a column in the data frame that can be used as an ID, so that as data frame rows are added, removed, or reordered, each row keeps a consistent key value.</li>
<li><strong>Visualizations</strong> - Crosstalk-compatible htmlwidget instances, essentially. Ideally, a visualization supports brushing, highlighting (emphasizing points that have been brushed elsewhere), and showing a subset of rows.</li>
<li><strong>Filter controls</strong> - Input widgets/controls that allow users to choose a subset of the data to display; for example, a slider over one of the numerical properties of the data, or a drop-down box with factor levels. Crosstalk itself comes with several filter inputs, and custom filter inputs can be written as well. (If you’re familiar with Shiny, these are like Shiny’s input widgets, except that they communicate with other client-side Crosstalk components instead of talking to a server.)</li>
<li><strong>Group</strong> - A set of visualizations and/or filter controls that are linked together for linked brushing and/or filtering purposes. It’s possible for a single web page to have more than one distinct Crosstalk group.</li>
</ul>
</div>
<div id="introduction-to-the-crosstalk-api" class="section level2">
<h2>Introduction to the Crosstalk API</h2>
<p>The Crosstalk API has two distinct parts: an R6 class, <code>SharedData</code>, that wraps a data frame; and a small JavaScript API through which widgets can send/receive messages to each other relating to brushing and filtering.</p>
<p>Creating a <code>SharedData</code> instance is easy. Its R6 constructor has one required and two optional components:</p>
<ul>
<li><code>data</code> - The underlying data frame. This can either be an actual data frame (or data frame-like) object, or a Shiny reactive expression that yields such an object.</li>
<li><code>key</code> - <em>[Optional]</em> Either a character vector or one-sided formula that indicates the key of the data frame (see the “Key” definition above). If not provided, then row names (if available) or row numbers will be used as keys.</li>
<li><code>group</code> - <em>[Optional]</em> The name of the Crosstalk group that visualizations/filter controls using this <code>SharedData</code> object should belong to. If not provided, a random group name is used, which should be fine in the vast majority of cases.</li>
</ul>
<p>Users signal their intention to use Crosstalk by passing your widget a <code>SharedData</code> instance instead of a regular data frame.</p>
<pre class="r"><code>df &lt;- read.csv(&quot;mydata.csv&quot;, stringsAsFactors=FALSE)
sd &lt;- SharedData$new(df)

# No Crosstalk
myWidget(df)

# Crosstalk enabled
myWidget(sd)</code></pre>
<p>As a widget author, you’ll want to extract the data frame, key, and group name using the <code>data</code>, <code>key</code>, and <code>groupName</code> methods, respectively.</p>
<p>Assuming you already have a working htmlwidget that works with data frames, the main thing you need to do is unwrap the underlying data frame and add the group name and key values to your widget payload (the <code>x</code> parameter in <code>htmlwidgets::createWidget()</code>).</p>
<p>Before:</p>
<pre class="r"><code>myWidget &lt;- function(data, width = NULL, height = NULL) {
  x &lt;- list(
    data = data
  )

  createWidget(&quot;myWidget&quot;, x, width=width, height=height)
}</code></pre>
<p>After:</p>
<pre class="r"><code>myWidget &lt;- function(data, width = NULL, height = NULL) {
  if (is.SharedData(data)) {
    # Using Crosstalk
    key &lt;- sharedData$key()
    group &lt;- sharedData$groupName()
    data &lt;- sharedData$data()
  } else {
    # Not using Crosstalk
    key &lt;- NULL
    group &lt;- NULL
  }

  x &lt;- list(
    data = data,
    settings = list(
      crosstalk_key = key,
      crosstalk_group = group
    )
  )

  createWidget(&quot;myWidget&quot;, x, width=width, height=height)
}</code></pre>
<p>Now in your JavaScript binding’s <code>renderValue</code> method, you can access <code>x.settings.crosstalk_key</code> and <code>x.settings.crosstalk_group</code>. To tell if Crosstalk is enabled for the current <code>renderValue</code> invocation, test one of these values for truthiness.</p>
</div>
<div id="implementing-interactions" class="section level2">
<h2>Implementing interactions</h2>
<p>Now the more difficult part: actually implementing the linked interactions on the JavaScript side.</p>
<p>Currently, Crosstalk supports two types of inter-widget interaction: linked brushing, and filtering. By “supports” I mean that Crosstalk will help visualizations and filter controls <em>communicate intentions</em> to each other. But actually implementing the selection, highlighting, and filtering behaviors for each widget type is the job of the widget author.</p>
<p>The sections below will discuss the types of interactions that are expected from each Crosstalk-compatible widget, and how to use Crosstalk’s JavaScript APIs to communicate.</p>
<p>// TODO: <code>htmlDependency</code> and R import</p>
<div id="linked-brushing" class="section level3">
<h3>Linked brushing</h3>
<p>Linked brushing lets the end user select data points in any visualization, to highlight the corresponding data points in all linked visualization.</p>
<p>At any given moment, only one visualization may have a selection; for example, if widget A has an active selection, and then the user begins making a selection on widget B, then widget A should immediately clear its selection.</p>
<p>Ideally, each visualization should be capable of the following:</p>
<ul>
<li>Allow the user to <u>make a selection</u>, usually through clicking on data points, or better, making a rectangular or lasso-shaped selection. (The result of the selection must be a subset of the rows in the dataset—that’s the only type of selection that is useful in Crosstalk.)</li>
<li><u>Clear a selection interactively</u> in response to a user gesture (i.e. clicking on an inert, unselected area of the visualization).</li>
<li><u>Clear a selection programmatically</u>, in response to another visualization (in the same Crosstalk group) starting a selection operation.</li>
<li><u>Highlight points</u> selected by another visualization. A common way to do this is to lower the opacity of data points that are not selected (and use the maximum opacity value for all data points when no selection is active in the group).</li>
</ul>
<p>In my experience so far, I’ve found 4 to be reasonably straightforward to achieve. But 1-3 can be difficult if you’re building on top of a JavaScript visualization library that isn’t designed to accomodate interactively selecting data points. Though it’s far preferable to support all four of these features, it’s possible to only support 4 to create what is essentially a “listen-only” Crosstalk participant.</p>
<div id="selection-javascript-api" class="section level4">
<h4>Selection JavaScript API</h4>
<p>Each Crosstalk-enabled visualization instance (i.e. each call to <code>renderValue</code>) should create a new <code>crosstalk.SelectionHandle</code> instance. Use <code>SelectionHandle</code> to read and write (and listen for changes to) the selection state for a Crosstalk group.</p>
<div id="construction" class="section level5">
<h5>Construction</h5>
<pre class="javascript"><code>var ct_sel = new crosstalk.SelectionHandle();</code></pre>
<p>If you know the Crosstalk group name at construction time, you can pass it as an argument to the constructor. If not, you can set it (and re-set it) later:</p>
<pre class="javascript"><code>ct_sel.setGroup(x.settings.crosstalk_group);</code></pre>
</div>
<div id="events" class="section level5">
<h5>Events</h5>
<p>Listen on the <code>&quot;change&quot;</code> event to be notified whenever the selection changes.</p>
<pre class="javascript"><code>ct_sel.on(&quot;change&quot;, function(e) { ... });</code></pre>
<p>The event handler will be called back with an object argument (<code>e</code> in the above example) that contains these properties:</p>
<ul>
<li><code>value</code> - Either falsy (meaning no selection is active) or a string array, where each element is the key of a selected data point/row. Any data point whose key does not appear in the string array should be considered deselected.</li>
<li><code>oldValue</code> - The previous value of the selection. A convenience for widgets that care to calculate the difference between the old and new values.</li>
<li><code>sender</code> - The <code>SelectionHandle</code> instance that made this change. Use <code>===</code> to compare to your own <code>SelectionHandle</code> to determine if the change is in response to an action you yourself took.</li>
</ul>
<p>You can unregister a previously registered event handler using either the return value of <code>on</code>, or with the function/closure itself.</p>
<pre class="javascript"><code>function myEventListener(e) { ... }
var subscription = ct_sel.on(&quot;change&quot;, myEventListener);

// These two lines are equivalent
ct_sel.off(&quot;change&quot;, subscription);
ct_sel.off(&quot;change&quot;, myEventListener);</code></pre>
</div>
<div id="getting-the-selection" class="section level5">
<h5>Getting the selection</h5>
<p>It may also be useful to get the selection value from places other than the change event handler. You can do this using the <code>value</code> property.</p>
<pre class="javascript"><code>var selected_keys = ct_sel.value;</code></pre>
</div>
<div id="setting-the-selection" class="section level5">
<h5>Setting the selection</h5>
<p>And of course, we need the ability to modify the selection. The <code>set</code> method changes the value and automatically triggers any change event listeners.</p>
<pre class="javascript"><code>ct_sel.set([&quot;Alaska&quot;, &quot;Rhode Island&quot;, &quot;Wyoming&quot;]);</code></pre>
<p>You can also easily clear the selection.</p>
<pre class="javascript"><code>ct_sel.clear();</code></pre>
</div>
<div id="cleaning-up" class="section level5">
<h5>Cleaning up</h5>
<p>Close the handle to remove all event handlers and remove the handle from the current group.</p>
<pre class="javascript"><code>ct_sel.close();</code></pre>
</div>
</div>
</div>
<div id="filtering" class="section level3">
<h3>Filtering</h3>
<p>Filtering causes a subset of data points to be shown, while all others are hidden.</p>
<p>With Crosstalk’s filtering API, multiple widgets simultaneously contribute to the current “filter set”. Crosstalk will determine which data points are permitted by all of the actively filtering widgets.</p>
<p>Earlier, we said that visualizations would ideally support both reading and writing of linked brushing state; that is, each plot should allow users to set the selection via direct manipulation, and also highlight points based on selections on other linked plots. While it’s possible to envision such functionality for filtering as well (see <a href="https://dc-js.github.io/dc.js/">dc.js</a>), it’s not currently recommended to do so with Crosstalk. Instead, the current design is geared toward distinct “filter controls” for input and “filtered visualizations” for output. Both types of controls will use the same <code>crosstalk.FilterHandle</code> class, but they will interact with it in different ways.</p>
<div id="filter-javascript-api" class="section level4">
<h4>Filter JavaScript API</h4>
<p>Construction, event handling, and setting of <code>crosstalk.FilterHandle</code> are almost identical to <code>SelectionHandle</code>:</p>
<pre class="javascript"><code>// Make instance
var ct_filter = new crosstalk.FilterHandle();

// Choose group
ct_filter.setGroup(x.settings.crosstalk_group);

// Get notified when this group&#39;s filter changes
ct_filter.on(&quot;change&quot;, function(e) {
  // e.value gives the filter
});

// Set this handle&#39;s filter keys
ct_filter.set([&quot;Washington&quot;, &quot;Oregon&quot;, &quot;Idaho&quot;]);

// Clear this handle&#39;s filter
ct_filter.clear();</code></pre>
<p><code>FilterHandle</code> doesn’t have a <code>value</code> property. Instead, it has a <code>filteredKeys</code> property. This property doesn’t simply return the most recently set filter value in the group; rather, each filter handle maintains its own set of keys (or none) and <code>filteredKeys</code> returns the <em>intersection</em> of them all.</p>
<p>For example:</p>
<pre class="javascript"><code>var filter1 = new crosstalk.FilterHandle(&quot;groupA&quot;);
var filter2 = new crosstalk.FilterHandle(&quot;groupA&quot;);
var filter3 = new crosstalk.FilterHandle(&quot;groupA&quot;);

filter1.set([&quot;New York&quot;, &quot;New Jersey&quot;, &quot;Connecticut&quot;]);
filter1.filteredKeys // [&quot;New York&quot;, &quot;New Jersey&quot;, &quot;Connecticut&quot;]

filter2.set([&quot;New York&quot;, &quot;Connecticut&quot;]);
filter1.filteredKeys // [&quot;New York&quot;, &quot;Connecticut&quot;];

filter3.set([&quot;New Jersey&quot;]);
filter3.filteredKeys // []

filter2.clear();
filter1.filteredKeys // [&quot;New Jersey&quot;]</code></pre>
<p>Note that it doesn’t matter which handle you call <code>filteredKeys</code> on. All filter handles that belong to the same group will return the same value for <code>filteredKeys</code>.</p>
</div>
</div>
<div id="putting-it-together" class="section level3">
<h3>Putting it together</h3>
<p>Here’s what the htmlwidget binding code for <a href="https://github.com/jcheng5/d3scatter">d3scatter</a> looks like, without Crosstalk support:</p>
<pre class="javascript"><code>HTMLWidgets.widget({

  name: &#39;d3scatter&#39;,

  type: &#39;output&#39;,

  factory: function(el, width, height) {

    var firstRun = true;
    var scatter = d3scatter(el).width(width).height(height);

    return {
      renderValue: function(x) {
        var value = x.data;
        scatter
          .x_var(value.x_var)
          .y_var(value.y_var)
          .color_var(value.color_var)
          .color_spec(value.color_spec)
          .x_label(value.x_label)
          .y_label(value.y_label)
          .x_lim(value.x_lim)
          .y_lim(value.y_lim);

        scatter(!firstRun);
        firstRun = false;
      },
      resize: function(width, height) {
        scatter.width(width).height(height)(false);
      }
    };
  }
});</code></pre>
<p>The d3scatter object is created at the scope of the <code>factory</code> function. Then, during <code>renderValue</code>, it’s updated with the <code>value</code> object.</p>
<p>The first step is to create a <code>crosstalk.SelectionHandle</code> object at the <code>factory</code> function level.</p>
<pre class="javascript"><code>var sel_handle = new crosstalk.SelectionHandle();</code></pre>
<p>We haven’t yet specified what group this handle should belong to. In fact, we won’t know the group until we receive a value via <code>renderValue</code> (and in some circumstances, <code>renderValue</code> might be called multiple times with different groups).</p>
<p>But we do have both <code>scatter</code> and <code>sel_handle</code> objects at this point, so we can wire them together. The d3scatter object has a <code>&quot;brush&quot;</code> event that we can use to update the Crosstalk selection handle, and the Crosstalk selection handle has a <code>&quot;change&quot;</code> event we can use to highlight the d3scatter data points appropriately.</p>
<pre class="javascript"><code>scatter.on(&quot;brush&quot;, function(keys) {
  sel_handle.set(keys);
});

sel_handle.on(&quot;change&quot;, function(e) {
  if (e.sender !== sel_handle) {
    scatter.clearBrush();
  }
  scatter.selection(e.value);
});</code></pre>
<p>With these relationships established inside of <code>factory</code>, we can now move on to <code>renderValue</code>. The only modifications we need are to pass the key data to the d3scatter object, and update the group of the <code>sel_handle</code> object.</p>
<p>The <code>SelectionHandle</code> change event provides a <code>value</code> property that indicates the currently selected keys as a string array; or, <code>value</code> can be <code>null</code> to indicate that no selection is active.</p>
<p>Notice the comparison <code>e.sender !== sel_handle</code>; this lets us distinguish between selection operations initiated by this widget instance versus by other instances, and to clear any active selection boundaries in the latter case.</p>
<p>The fully selection-enabled binding code is here:</p>
<pre class="javascript"><code>HTMLWidgets.widget({

  name: &#39;d3scatter&#39;,

  type: &#39;output&#39;,

  factory: function(el, width, height) {

    var firstRun = true;
    var scatter = d3scatter(el).width(width).height(height);

    var sel_handle = new crosstalk.SelectionHandle();

    scatter.on(&quot;brush&quot;, function(keys) {
      sel_handle.set(keys);
    });

    sel_handle.on(&quot;change&quot;, function(e) {
      if (e.sender !== sel_handle) {
        scatter.clearBrush();
      }
      scatter.selection(e.value);
    });

    return {
      renderValue: function(x) {
        var value = x.data;
        scatter
          .x_var(value.x_var)
          .y_var(value.y_var)
          .color_var(value.color_var)
          .color_spec(value.color_spec)
          .x_label(value.x_label)
          .y_label(value.y_label)
          .x_lim(value.x_lim)
          .y_lim(value.y_lim)
          .key(x.settings.crosstalk_key);

        sel_handle.setGroup(x.settings.crosstalk_group);

        scatter(!firstRun);
        firstRun = false;
      },
      resize: function(width, height) {
        scatter.width(width).height(height)(false);
      }
    };
  }
});</code></pre>
</div>
<div id="should-i-integrate-my-widget-with-crosstalk" class="section level3">
<h3>Should I integrate my widget with Crosstalk?</h3>
<p>Crosstalk makes a few demands on its widgets. If your widget doesn’t match all of the following criteria, you may find it difficult to integrate with Crosstalk in a sensible way.</p>
<div id="data-frame-or-data-frame-like-format-for-data" class="section level4">
<h4>Data frame (or data frame-like) format for data</h4>
<p>From the R side, your data must be represented in a data frame, or data frame-like object. In particular, it should work with the following S3 generics: - <strong><code>row.names()</code></strong> (this can return <code>NULL</code>, it just can’t error) - <strong><code>nrow()</code></strong> - <strong><code>$&lt;-</code></strong> (For example, <code>df$selected_ &lt;- ...</code> should add a new column called <code>selected_</code> if one doesn’t already exist) - <strong><code>[</code></strong> with two dimensions, e.g. <code>df[row, column]</code></p>
<p>This list of criteria may change in the future, so if you have implemented a data structure that you want to work with Crosstalk, the more you can make it look and feel like a data frame, the better.</p>
</div>
<div id="visualization-that-can-highlight-on-a-row-by-row-basis-for-linked-brushing" class="section level4">
<h4>Visualization that can highlight on a row-by-row basis (for linked brushing)</h4>
<p>The JavaScript visualization side of your widget must be able to highlight an arbitrary subset of rows.</p>
</div>
<div id="visualization-that-can-hideshow-on-a-row-by-row-basis-for-filtering" class="section level4">
<h4>Visualization that can hide/show on a row-by-row basis (for filtering)</h4>
</div>
</div>
</div>




</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.header').parent('thead').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
